---
title: "Bootstrap Confidence Interval"
author: "Kuei Yueh Ko"
date: "2017/3/29"
output: html_document
---

# Set up Environment

# Function Set Up
### Basic Functions
Function for probability distribution
```{r}
myUnif <- function(n, a=0, b=1) {
    # Continuous Uniform Distribution 
    # Default: R.V. ~ Uniform( [0,1] )
    #====================================
    x <- runif(n)      # R.V. ~~~ Uniform( [0,1] )
    y <- x * (b-a) + a # Shift to Uniform( [a,b] )
    return(y)
} # end func myUnif
```

Function for Sampling
```{r}
mySample <- function(x){
    # The function is based on 
    # return sample of x with replacement
    #===========================================
    # generate random numbers following uniform distribution
    n <- length(x)
    id <- myUnif(n, a=0, b=n)
    # convert continuous value into discrete
    id <- ceiling(id)
    # remove 0 (very rare case, p(X=0) is zero 
    # for any continuous random variable)
    id[id==0] <- 1 
    
    # return the result
    return(x[id])
} # end mySample
```

### Bootstrap
Function for Bootstrapping
```{r}
myBootstrap <- function(x, f, N){UseMethod("myBootstrap")}

myBootstrap.data.frame <- function(x, f, N){
    print("The input data is a data.frame...")
    # get id, the idx of rows
    id  <- seq_len(nrow(x))
    # bootstrapping
    print("Performing bootstrapping...")
    val <- replicate(
        N, f(x[mySample(id),])
    ) # end replicate
    
    # summary statistics & return the result 
    print("...Finished")
    res <- list()
    res$Val <- val       # bootstrap pedvalue
    res$MU  <- mean(val) # mean of bootstrapped value
    res$SE  <- sd(val)   # standard error of mean
    return(res)
} # end myJackknife.data.frame

myBootstrap.numeric <- function(x, f, N){
    print("The input data is a data.frame...")
    # get id, the idx of rows
    id  <- seq_len(length(x))
    # bootstrapping
    print("Performing bootstrapping...")
    val <- replicate(
        N, f(x[mySample(id)])
    ) # end replicate
    
    # summary statistics & return the result 
    print("...Finished")
    res <- list()
    res$Val <- val       # bootstrapped value
    res$MU  <- mean(val) # mean of bootstrapped value
    res$SE  <- sd(val)   # standard error of mean
    return(res)
} # end myJackknife.numeric
```

### Jackknife
Function for Jackknife
```{r}
myJackknife <- function(x, f){UseMethod("myJackknife")}

myJackknife.data.frame <- function(x, f){
    print("Input is data frame")
    n  <- nrow(x)
    id <- 1:n
    matID <- sapply(
        id, function(x){id[-x]}
    ) # end sapply
    colnames(matID) <- paste0("JK", id)
    
    print("Performing Jackknife...")
    val <- apply(
        matID, 2, 
        function(idx){
            f(
                x[idx,]
            )
        }  # end apply func
    ) # end apply
    
    print("...Finish")
    res <- list()
    res$MatID <- matID     
    res$Val   <- val       # Jackknife value
    res$MU    <- mean(val) # mean of Jackknife value
    # standard error of mean
    res$SE    <- ((n-1) / n * sum((val-mean(val))^2))^0.5
    return(res)
} # myJackknife.data.frame

myJackknife.numeric <- function(x, f){
    print("Input is numeric vector")
    n <- length(x)
    id <- 1:n
    matID <- sapply(
        id, function(x){id[-x]}
    ) # end sapply
    colnames(matID) <- paste0("JK", id)
    
    print("Performing Jackknife...")
    val <- apply(
        matID, 2, 
        function(idx){
            f(
                x[idx]
            )
        }  # end apply func
    ) # end apply
    
    print("...Finish")
    res <- list()
    res$MatID <- matID
    res$Val   <- val
    res$MU    <- mean(val)
    res$SE    <- ((n-1) / n * sum((val-mean(val))^2))^0.5
    return(res)
} # myJackknife.numeric
```

## BC Method
```{r}
createCDF <- function(val){
    # sort the value
    val <- sort(val)
    
    # create empirical CDF
    cdf <- function(x){
        prop <- mean(val <= x)
        return(prop)
    } # end inner func cdf
    
    # create inverse of empirical CDF
    cdfInv <- function(prop){
        idx <- round(length(val) * prop)
        x <- val[idx]
        return(x)
    } # end inner func cdfInv
    
    f <- list()
    f$Cdf <- cdf
    f$CdfInv <- cdfInv
    return(f)
}
```

## Bootstrap correction

Below is the formula of acceleration in BCa method

$$
\hat{a} = 
    \frac{
        \sum(
            \hat{\theta_{(.)}} - 
            \hat{\theta_{(i)}})^3
    }{
        6(\sum(
            \hat{\theta_{(.)}} - 
            \hat{\theta_{(i)}})^2)^{\frac{3}{2}}
    }
$$
Function to calculate Acceleration
```{r}
getAcceleration <- function(val, mu){
    valNew = val - mu
    print(valNew)
    # numerator
    x = valNew^3
    x = sum(x)
    # denominator
    y = valNew^2
    y = sum(y)
    y = 6 * y^(3/2)
    # return result
    return(x/y)
} # end func getAcceleration
```

Correction of Bootstrap confidence interval
```{r}
getBStrapCI <- function(
    val, theta, alpha=0.5,
    jKnife=NULL){
    
    f  <- createCDF(val)
    
    z0  <-  qnorm(f$Cdf(theta))
    zA2 <- -qnorm(alpha/2) 
    
    if (!is.null(jKnife)) {
        a   <- getAcceleration(jKnife$val, jKnife$MU)
        z2  <- z0 + (z0 + zA2) / (1 - a*(z0 + zA2))
        z1  <- z0 + (z0 - zA2) / (1 - a*(z0 - zA2))
    }else{
        z2  <- 2 * z0 + zA2
        z1  <- 2 * z0 - zA2
    } # end ifelse
    
    CI <- list()
    CI$upper <- f$CdfInv(pnorm(z2))
    CI$lower <- f$CdfInv(pnorm(z1))
    return(CI)
} # end func getCI
```

# Test on Sample Data
```{r}
# score of LSAT
x <- c(576, 635, 558, 578, 666, 580, 555, 661, 651, 605, 653, 575, 545, 572, 594)

# score of GPA 
y <- c(3.39, 3.30, 2.81, 3.03, 3.44, 3.07, 3.00, 3.42, 3.36, 3.13, 3.12, 2.74, 2.76, 2.88, 2.96)
```

```{r}
dat <- data.frame(X = x,Y=y)
myFunc <- function(dat){
    return(cor(dat$X,dat$Y))
} # end myFunc 

thetaHat <- myFunc(dat)
print(thetaHat)
```


```{r}
resJKnife <- myJackknife(dat, f=myFunc)
resBStrap <- myBootstrap(dat, f=myFunc, N=500)
```

```{r}
a = getAcceleration(resJKnife$Val, resJKnife$MU)
```

```{r}
getBStrapCI(
    val=resBStrap$Val,
    theta=thetaHat,
    alpha = 0.5)
```


```{r}
getBStrapCI(
    val=resBStrap$Val,
    theta=thetaHat,
    alpha = 0.5,
    jKnife=resJKnife)
```

```{r}
val <- 1:10
f <- createCDF(val)
sapply(val, f$Cdf)

```

# Import Density Data
```{r}

```


