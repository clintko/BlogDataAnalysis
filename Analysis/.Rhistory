# decide whether using BC or BCa
if (!is.null(jKnife)) {
a   <- getAcceleration(jKnife$Val, jKnife$MU)
z2  <- z0 + (z0 + zA2) / (1 - a*(z0 + zA2))
z1  <- z0 + (z0 - zA2) / (1 - a*(z0 - zA2))
}else{
a   <- NULL
z2  <- 2 * z0 + zA2
z1  <- 2 * z0 - zA2
} # end ifelse
# calculate the confidence interval
CI <- list()
CI$G     <- g
CI$Z0    <- z0
CI$Upper <- f$CdfInv(pnorm(z2))
CI$Lower <- f$CdfInv(pnorm(z1))
CI$Acceleration <- a
return(CI)
} # end func getCI
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 0.5)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,     "\n",
"Z0:           ", resBC$Z0,    "\n",
"Upper Bound:  ", resBC$Upper, "\n",
"Lower Bound:  ", resBC$Lower, "\n")
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 0.5)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,     "\n",
"Z0:           ", resBC$Z0,    "\n",
"Upper Bound:  ", resBC$Upper, "\n",
"Lower Bound:  ", resBC$Lower, "\n")
# Sample Correlation
thetaHat <- myFunc(dat)
# BC method
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0)
# BCa method
resBCa <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0,
jKnife=resJKnife)
thetaHat <- myFunc(dat)
# Recapitulate the data
dat <- data.frame(X=x,Y=y)
myFunc <- function(dat){
return(cor(dat$X,dat$Y))
} # end myFunc
thetaHat <- myFunc(dat)
# Sample Correlation
thetaHat <- myFunc(dat)
# BC method
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0)
# BCa method
resBCa <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0,
jKnife=resJKnife)
cat("",
"Sample Correlation (TheltaHat): ",
thetaHat)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,     "\n",
"Z0:           ", resBC$Z0,    "\n",
"Upper Bound:  ", resBC$Upper, "\n",
"Lower Bound:  ", resBC$Lower, "\n")
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa$Upper, "\n",
"Lower Bound:  ", resBCa$Lower, "\n",
"Acceleration: ", resBCa$Acceleration)
cat("",
"Sample Correlation (TheltaHat):\n",
thetaHat)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,     "\n",
"Z0:           ", resBC$Z0,    "\n",
"Upper Bound:  ", resBC$Upper, "\n",
"Lower Bound:  ", resBC$Lower, "\n")
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa$Upper, "\n",
"Lower Bound:  ", resBCa$Lower, "\n",
"Acceleration: ", resBCa$Acceleration)
getBStrapCI <- function(
val, theta, alpha=0.5,
jKnife=NULL){
# create empirical CDF
f  <- createCDF(val)
# find z0 and z[alpha/2]
g   <-  f$Cdf(theta)
z0  <-  qnorm(g)
zA2 <- -qnorm(alpha/2)
# decide whether using BC or BCa
if (!is.null(jKnife)) {
a   <- getAcceleration(jKnife$Val, jKnife$MU)
z2  <- z0 + (z0 + zA2) / (1 - a*(z0 + zA2))
z1  <- z0 + (z0 - zA2) / (1 - a*(z0 - zA2))
}else{
a   <- NULL
z2  <- 2 * z0 + zA2
z1  <- 2 * z0 - zA2
} # end ifelse
# calculate the confidence interval
CI <- list()
CI$G     <- g
CI$Z0    <- z0
CI$Z2    <- z2
CI$Z1    <- z1
CI$Upper <- f$CdfInv(pnorm(z2))
CI$Lower <- f$CdfInv(pnorm(z1))
CI$Acceleration <- a
return(CI)
} # end func getCI
# Sample Correlation
thetaHat <- myFunc(dat)
# BC method
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0)
# BCa method
resBCa <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0,
jKnife=resJKnife)
cat("",
"Sample Correlation (TheltaHat):\n",
thetaHat)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,     "\n",
"Z0:           ", resBC$Z0,    "\n",
"Z2:           ", resBC$Z2,    "\n",
"Z1:           ", resBC$Z1,    "\n",
"Upper Bound:  ", resBC$Upper, "\n",
"Lower Bound:  ", resBC$Lower, "\n")
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa$Upper, "\n",
"Lower Bound:  ", resBCa$Lower, "\n",
"Acceleration: ", resBCa$Acceleration)
getBStrapCI <- function(
val, theta, alpha=0.5,
jKnife=NULL){
# create empirical CDF
f  <- createCDF(val)
# find z0 and z[alpha/2]
g   <-  f$Cdf(theta)
z0  <-  qnorm(g)
zA2 <- -qnorm(alpha/2)
# decide whether using BC or BCa
if (!is.null(jKnife)) {
a   <- getAcceleration(jKnife$Val, jKnife$MU)
z2  <- z0 + (z0 + zA2) / (1 - a*(z0 + zA2))
z1  <- z0 + (z0 - zA2) / (1 - a*(z0 - zA2))
}else{
a   <- NULL
z2  <- 2 * z0 + zA2
z1  <- 2 * z0 - zA2
} # end ifelse
# calculate the confidence interval
CI <- list()
CI$G       <- g
CI$Z0      <- z0
CI$Z2      <- z2
CI$Z1      <- z1
CI$ZAlpha2 <- zA2
CI$Upper   <- f$CdfInv(pnorm(z2))
CI$Lower   <- f$CdfInv(pnorm(z1))
CI$Acceleration <- a
return(CI)
} # end func getCI
# Sample Correlation
thetaHat <- myFunc(dat)
# BC method
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0)
# BCa method
resBCa <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 1.0,
jKnife=resJKnife)
cat("",
"Sample Correlation (TheltaHat):\n",
thetaHat)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,      "\n",
"Z0:           ", resBC$Z0,     "\n",
"Z[Alpha/2]:   ", resBC$ZAlpha2,"\n",
"Z2:           ", resBC$Z2,     "\n",
"Z1:           ", resBC$Z1,     "\n",
"Upper Bound:  ", resBC$Upper,  "\n",
"Lower Bound:  ", resBC$Lower,  "\n")
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa$Upper, "\n",
"Lower Bound:  ", resBCa$Lower, "\n",
"Acceleration: ", resBCa$Acceleration)
# Sample Correlation
thetaHat <- myFunc(dat)
# BC method
resBC <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 0.1)
# BCa method
resBCa <- getBStrapCI(
val=resBStrap$Val,
theta=thetaHat,
alpha = 0.1,
jKnife=resJKnife)
cat("",
"Sample Correlation (TheltaHat):\n",
thetaHat)
cat("",
"BC Method", "\n",
"G(ThetaHat):  ", resBC$G,      "\n",
"Z0:           ", resBC$Z0,     "\n",
"Z[Alpha/2]:   ", resBC$ZAlpha2,"\n",
"Z2:           ", resBC$Z2,     "\n",
"Z1:           ", resBC$Z1,     "\n",
"Upper Bound:  ", resBC$Upper,  "\n",
"Lower Bound:  ", resBC$Lower,  "\n")
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa$Upper, "\n",
"Lower Bound:  ", resBCa$Lower, "\n",
"Acceleration: ", resBCa$Acceleration)
RegBeta <- function(x, y){
# Function RegBeta return the coefficient of
# linear regression
# x: independent variable
# y: dependent variable
###################################
# construct Design matrix
X <- as.matrix(cbind(1, x))
# solve by projecting to the solution space
b <- solve(t(X) %*% X) %*% t(X) %*% y
# return the parameters
return(b)
} # end func RegBeta
#################################
# Calculate & Store
# parameters of linear regression
beta <- list()
beta$Val <- RegBeta(x=cpodDens, y=fishDens)
beta$b0  <- beta$Val[1]
beta$b1  <- beta$Val[2]
# Encapitulate the data
dat <- data.frame(X=cpod$Val,Y=fish$Val)
# encapsulate the function
myFunc <- function(dat){
# the function input a data.frame, which contains two column X and Y
# perform the linear regression and acquire the coefficients
res <- RegBeta(x=dat$X, y=dat$Y)
return(as.vector(res))
} # end myFunc
BetaHat <- myFunc(dat)
BetaHat
cat("",
"Regression:\n",
"  Beta0: ", BetaHat[1], "\n",
"  Beta1: ", BetaHat[2], "\n")
resJKnife <- myJackknife(dat, f=myFunc)
resJKnife
bStrap_Beta <- myJackknife(dat, f=myFunc)
n <- nrow(dat)
res <- list()
val <- bStrap_Beta$Val[1,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- sd(val)
bStrap_Beta0 <- res
res <- list()
val <- bStrap_Beta$Val[2,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- sd(val)
bStrap_Beta1 <- res
bStrap_Beta0 <- res
bStrap_Beta <- myBootstrap(dat, f=myFunc, N=100)
bStrap_Beta <- myBootstrap(dat, f=myFunc, N=100)
res <- list()
val <- bStrap_Beta$Val[1,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- sd(val)
bStrap_Beta0 <- res
bStrap_Beta0
res <- list()
val <- bStrap_Beta$Val[2,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- sd(val)
bStrap_Beta1 <- res
bStrap_Beta1
jKnife_Beta <- myJackknife(dat, f=myFunc)
n <- nrow(dat)
res <- list()
val <- jKnife_Beta$Val[1,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- ((n-1) / n * sum((val-mean(val))^2))^0.5
jKnife_Beta0 <- res
res <- list()
val <- jKnife_Beta$Val[2,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- ((n-1) / n * sum((val-mean(val))^2))^0.5
jKnife_Beta1 <- res
bStrap_Beta <- myBootstrap(dat, f=myFunc, N=100)
res <- list()
val <- bStrap_Beta$Val[1,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- sd(val)
bStrap_Beta0 <- res
res <- list()
val <- bStrap_Beta$Val[2,]
res$Val   <- val
res$MU    <- mean(val)
res$SE    <- sd(val)
bStrap_Beta1 <- res
bStrap_Beta0
bStrap_Beta1
BetaHat <- myFunc(dat)
resBC_Beta0 <- getBStrapCI(
val=bStrap_Beta0$Val,
theta=BetaHat[1],
alpha = 0.05)
resBC_Beta1 <- getBStrapCI(
val=bStrap_Beta1$Val,
theta=BetaHat[2],
alpha = 0.05)
resBC_Beta1
resBC_Beta0
# Sample regression
BetaHat <- myFunc(dat)
# BC method
resBC_Beta0 <- getBStrapCI(
val=bStrap_Beta0$Val,
theta=BetaHat[1],
alpha = 0.05)
resBC_Beta1 <- getBStrapCI(
val=bStrap_Beta1$Val,
theta=BetaHat[2],
alpha = 0.05)
# BCa method
resBCa_Beta0 <- getBStrapCI(
val=bStrap_Beta0$Val,
theta=BetaHat[1],
alpha = 0.05,
jKnife=jKnife_Beta0)
resBCa_Beta1 <- getBStrapCI(
val=bStrap_Beta1$Val,
theta=BetaHat[2],
alpha = 0.05,
jKnife=jKnife_Beta1)
cat("",
"Regression:\n",
"  Beta0: ", BetaHat[1], "\n",
"  Beta1: ", BetaHat[2], "\n")
cat("",
"BC Method", "\n",
"Upper Bound:  ", resBC_Beta0$Upper,  "\n",
"Lower Bound:  ", resBC_Beta0$Lower,  "\n")
cat("",
"BC Method", "\n",
"Upper Bound:  ", resBC_Beta1$Upper,  "\n",
"Lower Bound:  ", resBC_Beta1$Lower,  "\n")
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa_Beta0$Upper, "\n",
"Lower Bound:  ", resBCa_Beta0$Lower, "\n",
"Acceleration: ", resBCa_Beta0$Acceleration)
cat("",
"BCa Method\n",
"Upper Bound:  ", resBCa_Beta1$Upper, "\n",
"Lower Bound:  ", resBCa_Beta1$Lower, "\n",
"Acceleration: ", resBCa_Beta1$Acceleration)
resBCa_Beta1$Lower
resBCa_Beta1$Z1
workdir
filePathData <- file.path(
workdir,"Data","StatCompEcology","Copepod")
cPodDensity <- read.table(file.path(
filePathData, "cop_density.txt"),
header=T)
cPodCompose <- read.table(file.path(
filePathData, "copepod_composition.txt"),
header=T)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist.txt"),
header=T)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist.txt"),
header=T)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist2.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist2.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist2.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist2.txt"),
header=F)
?read.delim
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist2.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist3.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist3.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist3.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist3.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist3.txt"),
header=F)
cpodSpecies <- read.table(file.path(
filePathData, "copepodSPlist3.txt"),
header=F)
cpodSpecies <- read.delim(file.path(
filePathData, "copepodSPlist.txt"),
header=F)
cpodSpecies[[1]]
rownames(cPodCompose) <- cpodSpecies[[1]]
head(cpodCompose)
head(cPodCompose)
dat <- cPodCompose / 100
dat <- cPodCompose / 100
# multiple total density to each row of matrix
res <- apply(
dat, 1,
function(x){x * cPodDensity[,1]})
res <- t(res)
head(res)
res[c("Oncaea Venusta", "Canthocalanus pauper"),]
cpodSpecies
res["Oncaea Venusta",]
rownames(res)
which(rownames(res) == "Oncaea Venusta")
which(rownames(res) == "Oncaea venusta")
res["Canthocalanus pauper",]
res[c("Oncaea venusta", "Canthocalanus pauper"),]
dat <- res[
c("Oncaea venusta",
"Canthocalanus pauper"),]
print(dat)
dat[1,]
dat[2,]
diff
val <-
sample(dat[1,], 500, replace = TRUE) -
sample(dat[2,], 500, replace = TRUE)
head(val)
hist(val)
res["Oncaea Venusta",]
res["Oncaea venusta",]
res["Canthocalanus pauper",]
# sample difference
thetaHat <- mean(dat[1,] - dat[2,])
# Bootstrap
val <-
sample(dat[1,], 500, replace = TRUE) -
sample(dat[2,], 500, replace = TRUE)
bStrap_DiffVal <- list()
bStrap_DiffVal$Val <- val
bStrap_DiffVal$MU  <- mean(val)
bStrap_DiffVal
getBStrapCI(
bStrap_DiffVal$Val,
theta=thetaHat,
alpha = 0.05)
hist(val, main="Distribution of bootstrapped mean differences")
