belEq(x, fitC5$par[1], fitC2$par[2]))
x <- seq(5, 20, by=0.5)
lines(x,belEq(x, fitC2$par[1], fitC2$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
x <- seq(5, 20, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC2$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20)
x <- seq(5, 20, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(5, 20))
x <- seq(8, 18, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(8, 20))
x <- seq(8, 18, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(8, 16))
x <- seq(8, 16, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(8, 16))
x <- seq(8, 15, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(8, 16))
x <- seq(8, 15.5, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(8, 16),
ylim=(0, 30))
x <- seq(8, 15.5, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(8, 16),
ylim=c(0, 30))
x <- seq(8, 15.5, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlim=c(7, 16),
ylim=c(0, 30))
x <- seq(8, 15.5, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
plot(
rep(dat$X.tempearture,4),
c(dat$C2, dat$C3, dat$C4, dat$C5),
col="red", pch=20,
xlab="Temperature",
ylab="Stage duration",
xlim=c(7, 16),
ylim=c(0, 30))
x <- seq(8, 15.5, by=0.5)
lines(x, belEq(x, fitC2$par[1], fitC2$par[2]))
lines(x, belEq(x, fitC3$par[1], fitC3$par[2]))
lines(x, belEq(x, fitC4$par[1], fitC4$par[2]))
lines(x, belEq(x, fitC5$par[1], fitC5$par[2]))
getDeri <- function(f, tol=0.000001){
# the function returns a
# derivative function of input f
#######################################
newFun <- function(x){
# dy/dx
delta <- (f(x+tol) - f(x)) / tol
return(delta)
} # end inner newFun
return(newFun)
} # end func
getLine <- function(slope, x, y) {
# from a slope and a point, we
# are able to define a line
#######################################
newFun <- function(px){
py  <- y + slope * (px-x)
return(py)
} # end inner newFun
return(newFun)
} # end fun getLine
findRoot <- function(f, x, tol=0.000001){
# the function return the next x
# using Newton-Ralphson method
#########################################
return(x - f(x) / getDeri(f, tol=tol)(x))
} # end func findRoot
getRoot <- function(f, x0, N=100){
# f: input function
# x0: initial value
# N: number of iterations
########################################
# initialization
y0 <- f(x0)
xi <- x0
yi <- y0
px <- c()
py <- c()
# search for the root
for (dummyNum in 1:N){
# store each point (x, y)
px <- c(px, xi)
py <- c(py, yi)
# update point (x, y)
xi <- findRoot(myFun, xi)
yi <- myFun(xi)
} # end for loop
# store the result
res <- list()
res$x <- px
res$y <- py
return(res)
} # end func getRoot
# choose a range
r <- c(-2, 10)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a random point
x0 <- 9
getLine <- function(slope, x, y) {
# from a slope and a point, we
# are able to define a line
#######################################
newFun <- function(px){
py  <- y + slope * (px-x)
return(py)
} # end inner newFun
return(newFun)
} # end fun getLine
plotTangent <- function(f, x, y, tol=0.000001, ...){
# this function help to plot
# the tangent line at the given point
#########################################
m <- getDeri(f, tol=tol)(x)
abline(a=getLine(m, x, y)(0), b=m, ...)
} # end fun plotLine
myFun <- function(x){
x^3
} # end func myFun
# choose a range
r <- c(-2, 10)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a random point
x0 <- 9
# plot function
plot(x, y, type="l", lwd=2, xlim=c(-0.5, 10))
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=20, col="red")
# choose a range
r <- c(-2, 10)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a random point
x0 <- 9
y0 <- myFun(x0)
# choose a range
r <- c(-2, 10)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a initial point
x0 <- 9
y0 <- myFun(x0)
# plot function
plot(x, y, type="l", lwd=2, xlim=c(-0.5, 10))
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=20, col="red")
res <- getRoot(myFun, x0 = x0, N = 5)
res
x
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5")
segments(x,0, x,y, col="#c0f0f0", lwd=2)
} # end for loop
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5")
segments(x,0, x,y, col="#c0f0f0", lwd=2)
} # end for loop
# set iteration
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5", lwd=4)
segments(x,0, x,y, col="#c0f0f0", lwd=2)
} # end for loop
# set iteration
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5", lwd=2)
segments(x,0, x,y, col="#c0f0f0", lwd=1, lty=2)
} # end for loop
# set iteration
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5", lwd=2)
segments(x,0, x,y, col="#c0f0f0", lwd=1, lty=2)
} # end for loop
# set iteration
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5", lwd=1)
segments(x,0, x,y, col="#c0f0f0", lwd=1, lty=2)
} # end for loop
# plot function
plot(x, y, type="l", lwd=2, xlim=c(-0.5, 10))
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=20, col="red")
# set iteration
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5", lwd=2)
segments(x,0, x,y, col="#c0f0f0", lwd=1, lty=2)
} # end for loop
# choose a range
r <- c(-2, 10)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a initial point
x0 <- 9
y0 <- myFun(x0)
#plot the function
plot(x, y, type="l", lwd=2, xlim=c(-0.5, 10))
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=20, col="red")
# set iteration
N <- 5
res <- getRoot(myFun, x0 = x0, N = N)
# show the process of searching a root
for(idx in 1:N){
x <- res$x[idx]
y <- res$y[idx]
plotTangent(myFun, x, y, col="#26a5a5", lwd=2)
segments(x,0, x,y, col="#c0f0f0", lwd=1, lty=2)
} # end for loop
points(res$x, res$y, col="blue")
myFun <- function(x){
sin(x) / x - 0.6
} # end func myFun
# choose a range
r <- c(-100, 100)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a initial point
x0 <- 5
y0 <- myFun(x0)
#plot the function
plot(x, y, type="l", lwd=2, xlim=c(-0.5, 10))
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# choose a range
r <- c(-100, 100)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a initial point
x0 <- 5
y0 <- myFun(x0)
# plot the function
plot(x, y, type="l", lwd=2, xlim=c(-0.5, 10))
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=20, col="red")
# choose a range
r <- c(-100, 100)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a initial point
x0 <- 5
y0 <- myFun(x0)
# plot the function
plot(x, y, type="l", lwd=2)
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=20, col="red")
# set iteration
N <- 100
res <- getRoot(myFun, x0 = x0, N = N)
# process of searching root
points(res$x, res$y, col="blue")
# choose a range
r <- c(-100, 100)
# sketch the function by points
x <- seq(r[1], r[2], by=0.1)
y <- myFun(x)
# choose a initial point
x0 <- 5
y0 <- myFun(x0)
# plot the function
plot(x, y, type="l", lwd=2)
abline(h=0, col="grey50")
abline(v=0, col="grey50")
# initial point
points(x0, y0, pch=19, col="red")
# set iteration
N <- 100
res <- getRoot(myFun, x0 = x0, N = N)
# process of searching root
points(res$x, res$y, col="blue", pch=20)
par(mfrow=c(1,2))
plot(p.x, type="l", xlab="Generation", ylab="Point X")
plot(p.y, type="l", xlab="Generation", ylab="Point Y")
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(res$x, type="l", xlab="Generation", ylab="Point X")
plot(res$y, type="l", xlab="Generation", ylab="Point Y")
par(mfrow=c(1,1))
# set iteration
N <- 200
res <- getRoot(myFun, x0 = x0, N = N)
# process of searching root
points(res$x, res$y, col="blue", pch=20)
par(mfrow=c(1,2))
plot(res$x, type="l", xlab="Generation", ylab="Point X")
plot(res$y, type="l", xlab="Generation", ylab="Point Y")
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(res$x, type="l", xlab="Generation", ylab="Value", main="Point X")
plot(res$y, type="l", xlab="Generation", ylab="Value", main="Point Y")
par(mfrow=c(1,1))
x <- runif(100)
hist(x)
y <- scale(x)
hist(y)
library(tidyr)
library(dplyr)
library(ggplot2)
library(readxl)
library(stringr)
library(data.tree)
# setup working directory
workdir <- "E:\\MEGA\\LAB\\LAB_JH\\Proj_EvoDevoPathway02\\labexp"
setwd(workdir)
# code directory
codedir <- "E:\\MEGA\\LAB\\LAB_JH\\Proj_EvoDevoPathway02\\labcode"
source(file.path(codedir, "Toolbox_General\\toolUseful.r"))
# file path
filePathKEGG <- file.path(workdir, "Data/KEGG")
#filePathHomolog <- file.path(workdir, "Data/Homologene")
#filePathPhylo   <- file.path(workdir, "Data/Phylostratigraphy")
#filePathENSEM   <- file.path(workdir, "Data/ENSEMBL")
#filePathTAX     <- file.path(workdir, "Data/NCBI_Tax")
#filePathFig <- "E:\\Dropbox\\Doc\\Thesis_KueiYuehKo\\Thesis\\Figures\\Fig01"
library(vegan)
library(cluster)
library(fpc)
library(dplyr)
workdir <- "C:\\Users\\clint\\Documents\\GitHub\\BlogDataAnalysis"
setwd(workdir)
filePathData <- file.path(
workdir,
"Data/StatCompEcology/Copepod")
envdata = read.table(
file.path(
filePathData,
'enviANDdensity.txt'),header=T)
View(envdata)
data = envdata[,-1]
data.std = scale(data)
View(data)
distEU = dist(data.std,method='euclidean')
matDist = as.matrix(distEU)
View(matDist)
resTree = agnes(distEU,method='ward')
resClus = cutree(resTree, k=5)
names(resClus) <- 1:34
resClus
plot(resTree)
resClus = cutree(resTree, k=5)
names(resClus) <- 1:34
resClus
n <- 34
idxPair <- t(combn(1:n, 2))
View(idxPair)
distPair <- apply(idxPair, 1, function(x){
idx1 <- x[1]
idx2 <- x[2]
res <- matDist[idx1,idx2]
}) # end apply
distRank <- rank(-distPair) # rank from the smallest
resClus
distPair < apply(idxPair, 1, function(x){
idx1 <- x[1]
idx2 <- x[2]
res <- matDist[idx1,idx2]
}) # end apply
distRank <- rank(-distPair) # rank from the smallest
isWithin <- apply(idxPair, 1, function(x){
idx1 <- x[1]
idx2 <- x[2]
res <- ifelse(resClus[idx1] == resClus[idx2], 1, 0)
})
isBetween <- ifelse(isWithin, 0, 1)
idxPair <- cbind(idxPair, distPair, distRank)
idxPair <- cbind(idxPair, isWithin, isBetween)
#convert to data frame
idxPair <- as.data.frame(idxPair)
View(idxPair)
idxPair$isWithin
rankW <- idxPair$distRank[
ifelse(idxPair$isWithin, T, F)]
rankB <- idxPair$distRank[
ifelse(idxPair$isBetween, T, F)]
M <- n * (n-1) / 2
statANOSIM <- (mean(rankW) - mean(rankB)) / (M/2)
statANOSIM
anosim(dat = matDist, grouping=resClus)
x <- idxPair$distPair
y <- idxPair$isBetween
statMantel <- sum(x*y)
statMantel
nrow(idxPair)
