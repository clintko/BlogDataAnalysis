dat <- datCPOD$CompDmtScale
boxplot(dat,
xaxt= "n",
#xlab="Species",
ylab="Percentage (%)",
main="Composition After Scaled")
axis(1, at=seq_len(ncol(dat)),
labels=colnames(dat),
las=2, cex.axis=0.7)
# set plot
par(mfrow=c(1,1))
par(mar = c(6,5,2,6))
lstOfDist <- list()
lstOfDist$MethodType <- c(
'Euclidean','Maximum','Manhattan',
'Canberra','Mahalanobis','Chord', 'Binary')
# real value
dat <- envdata$Scale
lstOfDist$Euclidean   = dist(dat ,method='Euclidean')
lstOfDist$Maximum     = dist(dat ,method='maximum')
lstOfDist$Manhattan   = dist(dat ,method='manhattan')
lstOfDist$Canberra    = dist(dat ,method='canberra')
lstOfDist$Mahalanobis = dist(dat, method='Mahalanobis')
lstOfDist$Chord       = dist(dat, method='Chord')
lstOfDist$Binary      = dist(dat, method='Binary')
# binary value
#dat <- envdata$
#lstofBin <- list()
#lstofBin$bin = dist(dat,method='binary')
lstOfDist <- list()
lstOfDist <- list()
lstOfDist$MethodType <- c(
'Euclidean','Maximum','Manhattan',
'Canberra','Mahalanobis','Chord')
# real value
#dat <- envdata$Scale
dat <- datCPOD$CompDmtScale
lstOfDist$Euclidean   = dist(dat ,method='Euclidean')
lstOfDist$Maximum     = dist(dat ,method='maximum')
lstOfDist$Manhattan   = dist(dat ,method='manhattan')
lstOfDist$Canberra    = dist(dat ,method='canberra')
lstOfDist$Mahalanobis = dist(dat, method='Mahalanobis')
lstOfDist$Chord       = dist(dat, method='Chord')
dim(lstOfDist$Euclidean)
source('~/.active-rstudio-document', echo=TRUE)
range(seqDiff(wss))
range(wss)
plot(1:15, wss, type="b", col="red3",
xlab="Number of Clusters",
ylab="Within groups sum of squares (WSS)"
)
plot(1:14, seqDiff(wss), type="b", col="grey50",
axes=F, xlab=NA, ylab=NA,
ylim=c(-150,100))
plot(1:15, wss, type="b", col="red3",
xlab="Number of Clusters",
ylab="Within groups sum of squares (WSS)",
ylim=c(300,1500))
# second plot
par(new = T)
plot(1:14, seqDiff(wss), type="b", col="grey50",
axes=F, xlab=NA, ylab=NA,
ylim=c(-150,100))
# First plot
plot(1:15, wss, type="b", col="red3",
xlab="Number of Clusters",
ylab="Within groups sum of squares (WSS)",
ylim=c(300,1500))
# second plot
par(new = T)
plot(1:14, seqDiff(wss), type="b", col="grey50",
axes=F, xlab=NA, ylab=NA,
ylim=c(-250,100))
# update the axis of second plot
axis(side = 4)
mtext(side = 4, line = 3, cex=1.0, 'Delta WSS')
# add legend
legend("topleft",
legend=c("WSS", "Delta WSS"),
lty=c(1,1), pch=c(NA, NA),
col=c("red3", "grey50"))
# First plot
plot(1:15, wss, type="b", col="red3",
xlab="Number of Clusters",
ylab="Within groups sum of squares (WSS)",
ylim=c(300,1500))
# second plot
par(new = T)
plot(1:14, seqDiff(wss), type="b", col="grey50",
axes=F, xlab=NA, ylab=NA,
ylim=c(-250,100))
# update the axis of second plot
axis(side = 4)
mtext(side = 4, line = 3, cex=1.0, 'Delta WSS')
# add legend
legend("topright",
legend=c("WSS", "Delta WSS"),
lty=c(1,1), pch=c(NA, NA),
col=c("red3", "grey50"))
# set parameters
dat <- datCPOD$CompDmtScale
matDist = lstOfDist$Euclidean
k = 5
y.pam = pam(d,k=k)
y.clara = clara(dat ,k=k)
# set parameters
dat <- datCPOD$CompDmtScale
matDist = lstOfDist$Euclidean
k = 5
y.pam = pam(matDist,k=k)
y.clara = clara(dat ,k=k)
y.pam$silinfo
plot(y.pam)
# set parameters
dat = datCPOD$CompDmtScale
matDist = lstOfDist$Euclidean
k = 2
y.pam = pam(matDist,k=k)
y.clara = clara(dat ,k=k)
y.pam$silinfo
plot(y.pam)
y.eucl.boot = clusterboot(dat, B=100, metric='euclidean', bootmethod=c('boot','subset'), clustermethod=claraCBI, usepam=TRUE, k=5, count=FALSE)
print(y.eucl.boot)
y.eucl.boot = clusterboot(dat, B=100, metric='euclidean', bootmethod=c('boot','subset'), clustermethod=claraCBI, usepam=TRUE, k=2, count=FALSE)
print(y.eucl.boot)
d = lstOfDist$Euclidean
y.eucl.ward = hclust(d, method='ward.D')  #two way of doing HC
y.eucl.ward = agnes(d, method='ward')
y.eucl.ave = agnes(d, method='average') # Edit 170417
y.eucl.dia = diana(d)
plot(y.eucl.ward,main='Wards-linkage Dendrogram',xlab='Station',labels=envdata[,1])
rect.hclust(y.eucl.ward,h=5) #cut by height
#y.eucl.ave = hclust(dist.eucl,method='average') # Edit 170417
summary(y.eucl.ward)$ac
coef(y.eucl.ward)
summary(y.eucl.ave)$ac
coef(y.eucl.ave)
plot(silhouette(cutree(cars.hclust,4),cars.dist))
kbest
names(kbest) <- lstOfDist$MethodType
print(kbest)
lstOfDist$MethodType
idx <- lstOfDist$MethodType[1]
idx
for (idx in lstOfDist$MethodType){
k = kbest[idx]
matDist = lstOfDist[[idx]]
}
k
matDist
idx
# initialization
dat = datCPOD$CompDmtScale
lstOfKClust <- list()
# kmeans
for (idx in lstOfDist$MethodType){
k = kbest[idx]
matDist = lstOfDist[[idx]]
lstOfKClust[[idx]] <- pam(matDist,k=k)
#lstOfKClust[[idx]] <- clara(dat , k=k)
# Note:
# Compared to other partitioning methods such as pam,
# clara can deal with much larger datasets. Each sub-
# dataset is partitioned into k clusters using the same
# algorithm as in pam.
} # end for loop
plot(lstOfKClust$Euclidean)
plot(lstOfKClust$Maximum)
plot(lstOfKClust$Chord)
plot(lstOfKClust$Manhattan)
plot(lstOfKClust$Canberra)
# initialization
dat <- datCPOD$CompDmtScale
lstOfKCBoot <- list()
# evaluate cluster stability
for (idx in lstOfDist$MethodType){
k = kbest[idx]
matDist = lstOfDist[[idx]]
lstOfKCBoot[[idx]] = clusterboot(
dat, B=100,
metric=idx, ## IMPORTANT
bootmethod=c('boot','subset'),
clustermethod=claraCBI,
usepam=TRUE,
k=k,        ## IMPORTANT
count=FALSE)
} # end for loop
names(lstOfKCBoot)
plot(lstOfKClust$Euclidean)
print(lstOfKCBoot$Euclidean)
plot(lstOfKClust$Manhattan)
print(lstOfKCBoot$Manhattan)
plot(lstOfKClust$Canberra)
print(lstOfKCBoot$Canberra)
plot(lstOfKClust$Chord)
print(lstOfKCBoot$Chord)
plot(lstOfKClust$Maximum)
print(lstOfKCBoot$Maximum)
print(lstOfKCBoot$Maximum)
# initialization
lstOfHClust_Ward <- list()
lstOfHClust_Ave  <- list()
lstOfDClust      <- list()
# Hierarchical Clustering
for (idx in lstOfDist$MethodType){
# set parameters
k = kbest[idx]
matDist = lstOfDist[[idx]]
# There are two ways for HC
#lstOfHClust_Ward[[idx]] <- hclust(matDist, method='ward.D')
lstOfHClust_Ward[[idx]] <- agnes(matDist, method='ward')
lstOfHClust_Ave[[idx]]  <- agnes(matDist, method='average')
# Diana
lstOfDClust[[idx]] <- diana(d)
} # end for loop
par(mfrow=c(1,3))
plot(lstOfHClust_Ward$Euclidean)
plot(lstOfHClust_Ward$Euclidean)
plot(lstOfHClust_Ward$Euclidean)
par(mfrow=c(1,3))
plot(lstOfHClust_Ward$Euclidean)
plot(lstOfHClust_Ward$Euclidean)
par(mfrow=c(1,1))
plot(lstOfHClust_Ward$Euclidean)
par(mfrow=c(1,2))
plot(lstOfHClust_Ward$Euclidean)
par(mfrow=c(2,1))
plot(lstOfHClust_Ward$Euclidean)
plot(lstOfHClust_Ave$Euclidean)
plot(lstOfDClust$Euclidean)
lstOfDist$MethodType
plot(lstOfHClust_Ward$Euclidean, k=5)
kbest
lapply(lstOfHClust_Ward, function(x){x$ac}
)
lapply(lstOfHClust_Ward, function(x){x$ac})
lapply(lstOfHClust_Ave, function(x){x$ac})
lapply(lstOfDClust, function(x){x$ac})
lapply(lstOfDClust, function(x){coef(x)})
res <- data.frame(
Method = c(
"Euclidean", "Manhattan",
"Canberra", "Chord" "Maximum")
k = c(2, 2, 2, 5, 12))
res <- data.frame(
Method = c(
"Euclidean", "Manhattan",
"Canberra", "Chord", "Maximum"),
k = c(2, 2, 2, 5, 12))
res
paste("AggoCoef", c("Ward", "Ave", "Diana"))
names(res) <- paste(c("Ward", "Ave", "Diana"))
paste(c("Ward", "Ave", "Diana"))
paste("AggoCoef", c("Ward", "Ave", "Diana"))
apply(resCompare, 1, function(x){
# set parameters
idx = x[1]
k   = x[2]
matDist <- lstOfDist[[idx]]
# Aggolmerative coefficient
res  = c()
temp = coef(lstOfHClust_Ward[[idx]])
res  = c(res, temp)
temp = coef(lstOfHClust_Ave[[idx]])
res  = c(res, temp)
temp = coef(lstOfDClust[[idx]])
res  = c(res, temp)
# cophenetic correlation
temp = cor(matDist, cophenetic(lstOfHClust_Ward[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfHClust_Ave[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfDClust[[idx]]))
res  = c(res, temp)
# return the result
names(res) <- c(
paste("AggoCoef", c("Ward", "Ave", "Diana")),
paste("CophCorr", c("Ward", "Ave", "Diana")))
return(res)
})
resCompare <- data.frame(
Method = c(
"Euclidean", "Manhattan",
"Canberra", "Chord", "Maximum"),
k = c(2, 2, 2, 5, 12))
apply(resCompare, 1, function(x){
# set parameters
idx = x[1]
k   = x[2]
matDist <- lstOfDist[[idx]]
# Aggolmerative coefficient
res  = c()
temp = coef(lstOfHClust_Ward[[idx]])
res  = c(res, temp)
temp = coef(lstOfHClust_Ave[[idx]])
res  = c(res, temp)
temp = coef(lstOfDClust[[idx]])
res  = c(res, temp)
# cophenetic correlation
temp = cor(matDist, cophenetic(lstOfHClust_Ward[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfHClust_Ave[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfDClust[[idx]]))
res  = c(res, temp)
# return the result
names(res) <- c(
paste("AggoCoef", c("Ward", "Ave", "Diana")),
paste("CophCorr", c("Ward", "Ave", "Diana")))
return(res)
})
c(temp)
temp <- apply(resCompare, 1, function(x){
# set parameters
idx = x[1]
k   = x[2]
matDist <- lstOfDist[[idx]]
# Aggolmerative coefficient
res  = c()
temp = coef(lstOfHClust_Ward[[idx]])
res  = c(res, temp)
temp = coef(lstOfHClust_Ave[[idx]])
res  = c(res, temp)
temp = coef(lstOfDClust[[idx]])
res  = c(res, temp)
# cophenetic correlation
temp = cor(matDist, cophenetic(lstOfHClust_Ward[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfHClust_Ave[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfDClust[[idx]]))
res  = c(res, temp)
# return the result
names(res) <- c(
paste("AggoCoef", c("Ward", "Ave", "Diana")),
paste("CophCorr", c("Ward", "Ave", "Diana")))
return(res)
})
c(temp)
temp
as.data.frame(temp)
t(as.data.frame(temp))
resCompare <- cbind(resCompare, t(as.data.frame(temp)))
resCompare
resCompare <- data.frame(
Method = c(
"Euclidean", "Manhattan",
"Canberra", "Chord", "Maximum"),
k = c(2, 2, 2, 5, 12))
temp <- apply(resCompare, 1, function(x){
# set parameters
idx = x[1]
k   = x[2]
matDist <- lstOfDist[[idx]]
# Aggolmerative coefficient
res  = c()
temp = coef(lstOfHClust_Ward[[idx]])
res  = c(res, temp)
temp = coef(lstOfHClust_Ave[[idx]])
res  = c(res, temp)
temp = coef(lstOfDClust[[idx]])
res  = c(res, temp)
# cophenetic correlation
temp = cor(matDist, cophenetic(lstOfHClust_Ward[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfHClust_Ave[[idx]]))
res  = c(res, temp)
temp = cor(matDist, cophenetic(lstOfDClust[[idx]]))
res  = c(res, temp)
# return the result
names(res) <- c(
paste("AggoCoef", c("Ward", "Ave", "Diana")),
paste("CophCorr", c("Ward", "Ave", "Diana")))
return(res)
})
# Combine results
resCompare <- cbind(resCompare, t(as.data.frame(temp)))
print(resCompare)
par(mfrow=c(3,2))
for(idx in lstOfDist$MethodType){
matDist <- lstofDist[[idx]]
fit <- lm(matDist~cophenetic(lstOfHClust_Ward[[idx]]))
plot(
matDist,
cophenetic(lstOfHClust_Ward[[idx]]),
xlab="Original distances",
ylab="Cophenetic distances",
main=idx)
#ablines(fit)
}
par(mfrow=c(3,2))
for(idx in lstOfDist$MethodType){
matDist <- lstOfDist[[idx]]
fit <- lm(matDist~cophenetic(lstOfHClust_Ward[[idx]]))
plot(
matDist,
cophenetic(lstOfHClust_Ward[[idx]]),
xlab="Original distances",
ylab="Cophenetic distances",
main=idx)
#ablines(fit)
}
par(mfrow=c(3,2))
par(mfrow=c(3,2))
for(idx in lstOfDist$MethodType){
matDist <- lstOfDist[[idx]]
#fit <- lm(matDist~cophenetic(lstOfHClust_Ward[[idx]]))
plot(
matDist,
cophenetic(lstOfHClust_Ward[[idx]]),
xlab="Original distances",
ylab="Cophenetic distances",
main=idx)
#ablines(fit)
}
fit <- lm(matDist~cophenetic(lstOfHClust_Ward[[idx]]))
as.vector(matDist)
fit <- lm(
as.vector(matDist)~
as.vector(cophenetic(lstOfHClust_Ward[[idx]])))
fit
abline(fit)
par(mfrow=c(3,2))
for(idx in lstOfDist$MethodType){
matDist <- lstOfDist[[idx]]
fit <- lm(
as.vector(matDist)~
as.vector(cophenetic(lstOfHClust_Ward[[idx]])))
plot(
matDist,
cophenetic(lstOfHClust_Ward[[idx]]),
xlab="Original distances",
ylab="Cophenetic distances",
main=idx)
abline(fit, col="red")
}
par(mfrow=c(1,1))
par(mfrow=c(3,2))
for(idx in lstOfDist$MethodType){
matDist <- lstOfDist[[idx]]
fit <- lm(
as.vector(cophenetic(lstOfHClust_Ward[[idx]]))~
as.vector(matDist))
plot(
matDist,
cophenetic(lstOfHClust_Ward[[idx]]),
xlab="Original distances",
ylab="Cophenetic distances",
main=idx)
abline(fit, col="red")
}
par(mfrow=c(1,1))
plot(silhouette(cutree(lstOfHClust_Ward$Euclidean,4),lstOfDist$Euclidean))
plot(silhouette(
cutree(lstOfHClust_Ward$Euclidean,2),
lstOfDist$Euclidean),
main="Silhouette Scores (HC; Ward Method; Euclidean Distance")
colnames(dat)
lstOfHClust_Ward$clustering
lstOfHClust_Ward$Euclidean$clustering
lstOfHClust_Ward$Euclidean$order
lstOfHClust_Ward$Euclidean
names(lstOfHClust_Ward$Euclidean)
names(lstOfKClust$Euclidean)
dat <- datCPOD$CompDmtScale
boxplot(dat[,"Acartia negligence"] ~ lstOfKClust$Euclidean$clustering)
boxplot(dat[,"Acartia negligence"] ~ lstOfKClust$Chord$clustering)
apply(dat, 1, sd)
which.max(apply(dat, 1, sd))
which.max(apply(dat, 2, sd))
boxplot(dat[,"Acartia pacifica "] ~ lstOfKClust$Chord$clustering)
boxplot(dat[,"Acartia pacifica"] ~ lstOfKClust$Chord$clustering)
which.max(apply(dat, 2, mad))
boxplot(dat[,"Canthocalanus pauper"] ~ lstOfKClust$Chord$clustering)
dat <- datCPOD$CompDmtScale
#which.max(apply(dat, 2, mad))
#=> Canthocalanus pauper
# plot
boxplot(
dat[,"Canthocalanus pauper"] ~ lstOfKClust$Chord$clustering,
xlab="Clusters (from K-Means, Chord Distance)",
ylab="Value"
main="Percent(%) of Canthocalanus pauper in Different Clusters")
dat <- datCPOD$CompDmtScale
#which.max(apply(dat, 2, mad))
#=> Canthocalanus pauper
# plot
boxplot(
dat[,"Canthocalanus pauper"] ~ lstOfKClust$Chord$clustering,
xlab="Clusters (from K-Means, Chord Distance)",
ylab="Value",
main="Percent(%) of Canthocalanus pauper in Different Clusters")
kruskal.test(
dat[,"Canthocalanus pauper"] ~ lstOfKClust$Chord$clustering
)
# initialization
lstOfHClust_Ward <- list()
lstOfHClust_Ave  <- list()
lstOfDClust      <- list()
# Hierarchical Clustering
for (idx in lstOfDist$MethodType){
# set parameters
k = kbest[idx]
matDist = lstOfDist[[idx]]
# There are two ways for HC
#lstOfHClust_Ward[[idx]] <- hclust(matDist, method='ward.D')
lstOfHClust_Ward[[idx]] <- agnes(matDist, method='ward')
lstOfHClust_Ave[[idx]]  <- agnes(matDist, method='average')
# Diana
lstOfDClust[[idx]] <- diana(d)
} # end for loop
source('~/.active-rstudio-document', echo=TRUE)
